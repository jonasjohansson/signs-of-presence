<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<title>Live Score</title>
<style>
  * {
    margin: 0; padding: 0; box-sizing: border-box;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
  }
  html, body {
    width: 100%; height: 100%;
    overflow: hidden;
    background: #000;
  }
  canvas#main {
    display: block;
    width: 100%; height: 100%;
    touch-action: none;
  }

  /* Settings toggle */
  #toggle-btn {
    position: fixed;
    top: max(10px, env(safe-area-inset-top));
    right: 10px;
    width: 40px; height: 40px;
    border-radius: 50%;
    background: rgba(40,40,40,0.4);
    border: 1px solid rgba(255,255,255,0.08);
    color: rgba(255,255,255,0.25);
    font-size: 18px;
    cursor: pointer;
    z-index: 20;
    display: flex; align-items: center; justify-content: center;
    transition: opacity 0.3s;
  }
  #toggle-btn:active { background: rgba(80,80,80,0.6); }

  /* Controls panel */
  #controls {
    position: fixed;
    bottom: 0; left: 0; right: 0;
    background: rgba(15,15,15,0.95);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    padding: 14px 20px;
    padding-bottom: max(14px, env(safe-area-inset-bottom));
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    gap: 18px;
    font-family: -apple-system, BlinkMacSystemFont, sans-serif;
    font-size: 13px;
    color: #777;
    transform: translateY(100%);
    transition: transform 0.3s ease;
    z-index: 10;
  }
  #controls.visible { transform: translateY(0); }

  .cg {
    display: flex; align-items: center; gap: 8px;
  }
  .cg label {
    white-space: nowrap;
    min-width: 36px;
  }
  .cg input[type="range"] {
    width: 80px;
    accent-color: #555;
  }
  .cg .v {
    min-width: 24px;
    text-align: right;
    font-variant-numeric: tabular-nums;
    color: #999;
  }
  #controls button {
    background: #222;
    border: 1px solid #333;
    color: #aaa;
    padding: 7px 16px;
    border-radius: 6px;
    font-size: 13px;
    font-family: inherit;
    cursor: pointer;
    white-space: nowrap;
  }
  #controls button:active { background: #444; }
</style>
</head>
<body>

<canvas id="main"></canvas>

<button id="toggle-btn" aria-label="Settings">&#9881;</button>

<div id="controls">
  <div class="cg">
    <label>Speed</label>
    <input type="range" id="r-speed" min="0" max="6" step="0.1" value="1.5">
    <span class="v" id="v-speed">1.5</span>
  </div>
  <div class="cg">
    <label>Fade</label>
    <input type="range" id="r-fade" min="0" max="20" step="1" value="8">
    <span class="v" id="v-fade">8</span>
  </div>
  <div class="cg">
    <label>Size</label>
    <input type="range" id="r-size" min="1" max="40" step="1" value="14">
    <span class="v" id="v-size">14</span>
  </div>
  <button id="btn-clear">Clear</button>
  <button id="btn-pause">Pause</button>
</div>

<script>
(() => {
  // ── DOM ──
  const canvas = document.getElementById('main');
  const ctx    = canvas.getContext('2d');
  const score  = document.createElement('canvas');
  const sctx   = score.getContext('2d');

  // ── Settings ──
  let scrollSpeed  = 1.5;   // CSS px per frame
  let fadeIntensity = 8;     // 0‑20 slider units
  let maxRadius    = 14;     // max brush radius at full pressure
  let paused       = false;

  // ── Derived ──
  let W, H, dpr;
  let lanes = [];            // Y of the 2 divider lines
  let fadeGrad = null;

  // ── Drawing state ──
  let drawing = false;
  let prevX = 0, prevY = 0, prevP = 0;

  // ────────────────────────────────────────────
  //  Resize
  // ────────────────────────────────────────────
  function resize() {
    dpr = window.devicePixelRatio || 1;
    W = window.innerWidth;
    H = window.innerHeight;

    // Preserve existing score
    const tmp = document.createElement('canvas');
    tmp.width = score.width;
    tmp.height = score.height;
    if (score.width > 0 && score.height > 0) {
      tmp.getContext('2d').drawImage(score, 0, 0);
    }

    canvas.width  = W * dpr;
    canvas.height = H * dpr;
    score.width   = W * dpr;
    score.height  = H * dpr;

    // Restore
    if (tmp.width > 0 && tmp.height > 0) {
      sctx.drawImage(tmp, 0, 0, tmp.width, tmp.height, 0, 0, score.width, score.height);
    }

    // Scale contexts so we can work in CSS‑pixel coords
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    sctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // 2 divider lines → 3 equal tracks
    lanes = [H / 3, (H * 2) / 3];

    buildFadeGradient();
  }

  // ────────────────────────────────────────────
  //  Fade gradient  (stronger on left, weaker on right)
  // ────────────────────────────────────────────
  function buildFadeGradient() {
    // Work in physical pixels (gradient applied with reset transform)
    fadeGrad = sctx.createLinearGradient(0, 0, score.width, 0);
    const m = fadeIntensity / 10;           // 0 → 0, 10 → 1.0, 20 → 2.0
    fadeGrad.addColorStop(0,    rgba(0.030 * m));
    fadeGrad.addColorStop(0.35, rgba(0.014 * m));
    fadeGrad.addColorStop(0.65, rgba(0.006 * m));
    fadeGrad.addColorStop(1.0,  rgba(0.002 * m));
  }
  function rgba(a) {
    return `rgba(0,0,0,${Math.min(a, 1).toFixed(5)})`;
  }

  // ────────────────────────────────────────────
  //  Brush
  // ────────────────────────────────────────────
  function stamp(x, y, pressure) {
    const r = Math.max(0.8, pressure * maxRadius);
    sctx.beginPath();
    sctx.arc(x, y, r, 0, Math.PI * 2);
    sctx.fill();
  }

  function strokeSegment(x0, y0, p0, x1, y1, p1) {
    const dx = x1 - x0, dy = y1 - y0;
    const dist = Math.hypot(dx, dy);

    if (dist < 0.5) { stamp(x1, y1, p1); return; }

    const avgR = Math.max(1, ((p0 + p1) / 2) * maxRadius);
    const spacing = Math.max(0.8, avgR * 0.25);
    const n = Math.max(1, Math.ceil(dist / spacing));

    for (let i = 0; i <= n; i++) {
      const t = i / n;
      stamp(
        x0 + dx * t,
        y0 + dy * t,
        p0 + (p1 - p0) * t
      );
    }
  }

  // ────────────────────────────────────────────
  //  Pointer events  (pen + mouse; ignore finger)
  // ────────────────────────────────────────────
  function onDown(e) {
    if (e.pointerType === 'touch') return;
    e.preventDefault();
    canvas.setPointerCapture(e.pointerId);

    drawing = true;
    prevX = e.clientX;
    prevY = e.clientY;
    prevP = e.pressure || 0.5;

    sctx.fillStyle = '#fff';
    stamp(prevX, prevY, prevP);
  }

  function onMove(e) {
    if (!drawing) return;
    e.preventDefault();

    const events = e.getCoalescedEvents ? e.getCoalescedEvents() : [e];
    sctx.fillStyle = '#fff';

    for (const ce of events) {
      const x = ce.clientX;
      const y = ce.clientY;
      const p = ce.pressure || 0.5;
      strokeSegment(prevX, prevY, prevP, x, y, p);
      prevX = x;
      prevY = y;
      prevP = p;
    }
  }

  function onUp() { drawing = false; }

  canvas.addEventListener('pointerdown', onDown);
  canvas.addEventListener('pointermove', onMove);
  canvas.addEventListener('pointerup', onUp);
  canvas.addEventListener('pointercancel', onUp);

  // ────────────────────────────────────────────
  //  Animation loop
  // ────────────────────────────────────────────
  function frame() {
    // 1) Scroll score canvas left
    if (!paused && scrollSpeed > 0) {
      const shift = scrollSpeed * dpr;
      sctx.save();
      sctx.setTransform(1, 0, 0, 1, 0, 0);
      sctx.globalCompositeOperation = 'copy';
      sctx.drawImage(score, -shift, 0);
      sctx.globalCompositeOperation = 'source-over';
      sctx.restore();

      // Keep continuous strokes connected after scroll
      if (drawing) prevX -= scrollSpeed;
    }

    // 2) Fade (gradient: strong left, gentle right)
    if (fadeIntensity > 0) {
      sctx.save();
      sctx.setTransform(1, 0, 0, 1, 0, 0);
      sctx.fillStyle = fadeGrad;
      sctx.fillRect(0, 0, score.width, score.height);
      sctx.restore();
    }

    // 3) Render to display canvas
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(score, 0, 0);
    ctx.restore();

    // Back to CSS‑pixel coords
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // 4) Staff lines (2 dividers → 3 tracks)
    ctx.strokeStyle = 'rgba(255,255,255,0.22)';
    ctx.lineWidth = 1;
    for (const y of lanes) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(W, y);
      ctx.stroke();
    }

    // 5) Drawing‑zone indicator (subtle dashed line at 75% width)
    const zx = W * 0.75;
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.lineWidth = 1;
    ctx.setLineDash([5, 10]);
    ctx.beginPath();
    ctx.moveTo(zx, 0);
    ctx.lineTo(zx, H);
    ctx.stroke();
    ctx.restore();

    requestAnimationFrame(frame);
  }

  // ────────────────────────────────────────────
  //  Controls
  // ────────────────────────────────────────────
  const toggleBtn = document.getElementById('toggle-btn');
  const controls  = document.getElementById('controls');

  toggleBtn.addEventListener('click', () => controls.classList.toggle('visible'));

  // Speed
  const rSpeed = document.getElementById('r-speed');
  const vSpeed = document.getElementById('v-speed');
  rSpeed.addEventListener('input', () => {
    scrollSpeed = parseFloat(rSpeed.value);
    vSpeed.textContent = scrollSpeed.toFixed(1);
  });

  // Fade
  const rFade = document.getElementById('r-fade');
  const vFade = document.getElementById('v-fade');
  rFade.addEventListener('input', () => {
    fadeIntensity = parseInt(rFade.value, 10);
    vFade.textContent = fadeIntensity;
    buildFadeGradient();
  });

  // Brush size
  const rSize = document.getElementById('r-size');
  const vSize = document.getElementById('v-size');
  rSize.addEventListener('input', () => {
    maxRadius = parseInt(rSize.value, 10);
    vSize.textContent = maxRadius;
  });

  // Clear
  document.getElementById('btn-clear').addEventListener('click', () => {
    sctx.save();
    sctx.setTransform(1, 0, 0, 1, 0, 0);
    sctx.clearRect(0, 0, score.width, score.height);
    sctx.restore();
  });

  // Pause / Play
  const btnPause = document.getElementById('btn-pause');
  btnPause.addEventListener('click', () => {
    paused = !paused;
    btnPause.textContent = paused ? 'Play' : 'Pause';
  });

  // ── Init ──
  window.addEventListener('resize', resize);
  resize();
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
