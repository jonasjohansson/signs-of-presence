<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<title>Live Score</title>
<style>
  * {
    margin: 0; padding: 0; box-sizing: border-box;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
  }
  html, body {
    width: 100%; height: 100%;
    overflow: hidden;
    background: #000;
  }
  canvas#main {
    display: block;
    width: 100%; height: 100%;
    touch-action: none;
  }

  /* ── Brush sidebar (left, Procreate‑style) ── */
  #brush-sidebar {
    position: fixed;
    left: 14px;
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    z-index: 20;
  }

  /* Vertical slider */
  .vslider {
    position: relative;
    width: 30px;
    height: 140px;
    background: rgba(35,35,35,0.92);
    border-radius: 15px;
    border: 1px solid rgba(255,255,255,0.06);
    overflow: hidden;
    cursor: ns-resize;
    touch-action: none;
  }
  .vslider-fill {
    position: absolute;
    bottom: 0; left: 0; right: 0;
    background: rgba(255,255,255,0.13);
    border-radius: 15px;
    pointer-events: none;
  }
  .vslider-label {
    position: absolute;
    width: 100%;
    text-align: center;
    top: 6px;
    font-family: -apple-system, sans-serif;
    font-size: 8px;
    letter-spacing: 0.5px;
    text-transform: uppercase;
    color: rgba(255,255,255,0.25);
    pointer-events: none;
  }

  /* Brush preview */
  #brush-preview {
    width: 36px; height: 36px;
    display: flex; align-items: center; justify-content: center;
  }
  #brush-dot {
    border-radius: 50%;
    background: #fff;
  }

  /* Brush settings button */
  #btn-brush-panel {
    width: 30px; height: 30px;
    border-radius: 50%;
    background: rgba(35,35,35,0.92);
    border: 1px solid rgba(255,255,255,0.06);
    color: rgba(255,255,255,0.3);
    font-size: 14px;
    cursor: pointer;
    display: flex; align-items: center; justify-content: center;
  }
  #btn-brush-panel:active { background: rgba(60,60,60,0.9); }
  .sb-btn {
    width: 30px; height: 30px;
    border-radius: 50%;
    background: rgba(35,35,35,0.92);
    border: 1px solid rgba(255,255,255,0.06);
    color: rgba(255,255,255,0.3);
    font-size: 12px;
    cursor: pointer;
    display: flex; align-items: center; justify-content: center;
  }
  .sb-btn:active { background: rgba(60,60,60,0.9); }
  .sb-btn.active { background: rgba(80,50,20,0.9); color: rgba(255,180,60,0.7); }

  /* ── Brush settings panel ── */
  #brush-panel {
    position: fixed;
    left: 60px;
    top: 50%;
    transform: translateY(-50%) scale(0.95);
    opacity: 0;
    pointer-events: none;
    width: 230px;
    background: rgba(22,22,22,0.96);
    backdrop-filter: blur(16px);
    -webkit-backdrop-filter: blur(16px);
    border: 1px solid rgba(255,255,255,0.07);
    border-radius: 14px;
    padding: 16px;
    font-family: -apple-system, sans-serif;
    font-size: 12px;
    color: #888;
    z-index: 25;
    transition: opacity 0.2s, transform 0.2s;
  }
  #brush-panel.open {
    opacity: 1;
    pointer-events: auto;
    transform: translateY(-50%) scale(1);
  }
  .bp-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 14px;
    font-size: 13px;
    font-weight: 600;
    color: #aaa;
  }
  .bp-close {
    background: none; border: none;
    color: #666; font-size: 18px;
    cursor: pointer; padding: 0 2px;
  }
  .bp-close:active { color: #aaa; }
  .bp-row {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 10px;
  }
  .bp-row:last-child { margin-bottom: 0; }
  .bp-row label {
    flex: 0 0 82px;
    font-size: 11px;
    color: #666;
  }
  .bp-row input[type="range"] {
    flex: 1;
    accent-color: #555;
    height: 18px;
  }
  .bp-row .bp-val {
    flex: 0 0 28px;
    text-align: right;
    font-size: 10px;
    font-variant-numeric: tabular-nums;
    color: #777;
  }

  /* ── Stylus HUD ── */
  #stylus-hud {
    position: fixed;
    top: max(10px, env(safe-area-inset-top));
    left: 60px;
    background: rgba(15,15,15,0.85);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 10px;
    padding: 8px 12px;
    font-family: 'SF Mono', ui-monospace, monospace;
    font-size: 10px;
    line-height: 1.65;
    color: #555;
    z-index: 20;
    pointer-events: none;
    min-width: 170px;
  }
  #stylus-hud .hl { color: #444; display: inline-block; width: 66px; }
  #stylus-hud .hv { color: #888; font-variant-numeric: tabular-nums; }
  .hbar {
    display: inline-block; width: 44px; height: 3px;
    background: #1a1a1a; border-radius: 2px;
    vertical-align: middle; margin-left: 4px;
    overflow: hidden;
  }
  .hbar-fill {
    height: 100%; background: #666; border-radius: 2px;
    transition: width 0.06s;
  }

</style>
</head>
<body>

<canvas id="main"></canvas>

<!-- Stylus HUD -->
<div id="stylus-hud">
  <div><span class="hl">type</span><span class="hv" id="s-type">--</span></div>
  <div><span class="hl">pressure</span><span class="hv" id="s-pressure">--</span><span class="hbar"><span class="hbar-fill" id="s-pbar" style="width:0%"></span></span></div>
  <div><span class="hl">tiltX</span><span class="hv" id="s-tiltx">--</span></div>
  <div><span class="hl">tiltY</span><span class="hv" id="s-tilty">--</span></div>
  <div><span class="hl">altitude</span><span class="hv" id="s-alt">--</span></div>
  <div><span class="hl">azimuth</span><span class="hv" id="s-azi">--</span></div>
  <div><span class="hl">twist</span><span class="hv" id="s-twist">--</span></div>
  <div><span class="hl">position</span><span class="hv" id="s-pos">--</span></div>
</div>

<!-- Brush sidebar -->
<div id="brush-sidebar">
  <div class="vslider" id="vs-size">
    <div class="vslider-fill" id="vsf-size"></div>
    <div class="vslider-label">Size</div>
  </div>
  <div id="brush-preview"><div id="brush-dot"></div></div>
  <div class="vslider" id="vs-opacity">
    <div class="vslider-fill" id="vsf-opacity"></div>
    <div class="vslider-label">Opacity</div>
  </div>
  <div class="vslider" id="vs-speed">
    <div class="vslider-fill" id="vsf-speed"></div>
    <div class="vslider-label">Speed</div>
  </div>
  <button id="btn-brush-panel">&#9998;</button>
  <button class="sb-btn" id="btn-pause">&#9646;&#9646;</button>
  <button class="sb-btn" id="btn-clear">&times;</button>
</div>

<!-- Brush settings panel -->
<div id="brush-panel">
  <div class="bp-header">Brush <button class="bp-close" id="bp-close">&times;</button></div>
  <div class="bp-row"><label>Streamline</label><input type="range" id="bp-stream" min="0" max="95" value="30"><span class="bp-val" id="bpv-stream">30</span></div>
  <div class="bp-row"><label>Sensitivity</label><input type="range" id="bp-pcurve" min="20" max="200" value="35"><span class="bp-val" id="bpv-pcurve">35</span></div>
  <div class="bp-row"><label>Press &rarr; Size</label><input type="range" id="bp-psize" min="0" max="100" value="100"><span class="bp-val" id="bpv-psize">100</span></div>
  <div class="bp-row"><label>Press &rarr; Opac</label><input type="range" id="bp-popac" min="0" max="100" value="15"><span class="bp-val" id="bpv-popac">15</span></div>
  <div class="bp-row"><label>Speed Thin</label><input type="range" id="bp-vel" min="0" max="100" value="30"><span class="bp-val" id="bpv-vel">30</span></div>
  <div class="bp-row"><label>Min Size</label><input type="range" id="bp-min" min="1" max="50" value="2"><span class="bp-val" id="bpv-min">2</span></div>
  <div class="bp-row"><label>Softness</label><input type="range" id="bp-soft" min="0" max="100" value="15"><span class="bp-val" id="bpv-soft">15</span></div>
  <div class="bp-row"><label>Tilt &rarr; Shape</label><input type="range" id="bp-tilt" min="0" max="100" value="70"><span class="bp-val" id="bpv-tilt">70</span></div>
  <div class="bp-row"><label>Scatter</label><input type="range" id="bp-scatter" min="0" max="100" value="0"><span class="bp-val" id="bpv-scatter">0</span></div>
  <div class="bp-row"><label>Scatter Dens</label><input type="range" id="bp-sdens" min="1" max="12" value="4"><span class="bp-val" id="bpv-sdens">4</span></div>
</div>

<script>
(() => {
  // ── Canvases ──
  const canvas = document.getElementById('main');
  const ctx    = canvas.getContext('2d');
  const score  = document.createElement('canvas');
  const sctx   = score.getContext('2d');

  // ── Pre‑rendered dab ──
  const DAB_RES = 128;
  const dabCvs  = document.createElement('canvas');
  const dabCtx  = dabCvs.getContext('2d');
  dabCvs.width = dabCvs.height = DAB_RES;

  // ── App state ──
  let W, H, dpr;
  let lanes       = [];
  let scrollSpeed = 1.5;
  let paused      = false;

  // ── Brush params ──
  let maxRadius       = 40;
  let brushOpacity    = 1.0;
  let streamline      = 0.30;   // 0–0.95
  let pressureCurve   = 0.35;   // power exponent (< 1 = very sensitive)
  let pressureToSize  = 1.00;   // 0–1  (full pressure→size range)
  let pressureToOpac  = 0.15;   // 0–1
  let speedThinning   = 0.30;   // 0–1
  let minSizePct      = 0.02;   // 0–0.5 (very thin at light touch)
  let softness        = 0.15;   // 0–1
  let tiltInfluence   = 0.70;   // 0–1  (tilt → elliptical brush)
  let scatterRadius   = 0;      // 0–1  (0 = off)
  let scatterDensity  = 4;      // extra dabs per stamp

  // ── Drawing state ──
  let drawing = false;
  let prevDX = 0, prevDY = 0, prevDP = 0;
  let smoothX = 0, smoothY = 0;
  let smoothP = 0;
  let lastTime = 0;
  let lastVelocity = 0;
  // Tilt smoothing
  let smTiltCos = 0, smTiltSin = 0, smAspect = 1;
  let curAngle = 0, curAspect = 1;
  // Track locking
  let activeTrackTop = 0, activeTrackBot = 0;
  let trackBounds = [];

  // ── HUD refs ──
  const sType = document.getElementById('s-type');
  const sPressure = document.getElementById('s-pressure');
  const sPbar = document.getElementById('s-pbar');
  const sTiltX = document.getElementById('s-tiltx');
  const sTiltY = document.getElementById('s-tilty');
  const sAlt = document.getElementById('s-alt');
  const sAzi = document.getElementById('s-azi');
  const sTwist = document.getElementById('s-twist');
  const sPos = document.getElementById('s-pos');

  // ══════════════════════════════════════════════
  //  Resize
  // ══════════════════════════════════════════════
  function resize() {
    dpr = window.devicePixelRatio || 1;
    W = window.innerWidth;
    H = window.innerHeight;

    const tmp = document.createElement('canvas');
    tmp.width = score.width; tmp.height = score.height;
    if (score.width > 0 && score.height > 0)
      tmp.getContext('2d').drawImage(score, 0, 0);

    canvas.width = W * dpr; canvas.height = H * dpr;
    score.width  = W * dpr; score.height  = H * dpr;

    if (tmp.width > 0 && tmp.height > 0)
      sctx.drawImage(tmp, 0, 0, tmp.width, tmp.height, 0, 0, score.width, score.height);

    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    sctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // Score area with margins for UI
    const MARGIN = 0.12;  // 12% top and bottom
    const scoreTop = H * MARGIN;
    const scoreBot = H * (1 - MARGIN);
    const scoreH   = scoreBot - scoreTop;
    const thirdH   = scoreH / 3;           // height of each "third"
    const TRACK_RATIO = 0.55;              // track fills 55% of its third
    const trackH = thirdH * TRACK_RATIO;
    const pad    = (thirdH - trackH) / 2;  // padding above/below each track

    // 3 tracks, each centered in its third
    trackBounds = [];
    lanes = [];
    for (let i = 0; i < 3; i++) {
      const thirdTop = scoreTop + i * thirdH;
      const tTop = thirdTop + pad;
      const tBot = thirdTop + pad + trackH;
      trackBounds.push({ top: tTop, bot: tBot });
      lanes.push(tTop);
      lanes.push(tBot);
    }
  }

  // ══════════════════════════════════════════════
  //  Build soft dab texture
  // ══════════════════════════════════════════════
  function buildDab() {
    dabCtx.clearRect(0, 0, DAB_RES, DAB_RES);
    const c = DAB_RES / 2;
    const grad = dabCtx.createRadialGradient(c, c, 0, c, c, c);
    const hard = Math.max(0.01, 1 - softness);
    grad.addColorStop(0, '#fff');
    grad.addColorStop(Math.min(hard, 0.99), '#fff');
    grad.addColorStop(1, 'rgba(255,255,255,0)');
    dabCtx.fillStyle = grad;
    dabCtx.beginPath();
    dabCtx.arc(c, c, c, 0, Math.PI * 2);
    dabCtx.fill();
  }

  // ══════════════════════════════════════════════
  //  Tilt computation
  // ══════════════════════════════════════════════
  function computeTilt(e) {
    if (tiltInfluence <= 0) { curAngle = 0; curAspect = 1; return; }

    let rawAngle = 0, tiltAmount = 0;

    if (e.altitudeAngle != null && e.azimuthAngle != null) {
      rawAngle = e.azimuthAngle;
      tiltAmount = 1 - (e.altitudeAngle / (Math.PI / 2)); // 0=vertical 1=flat
    } else {
      const tx = (e.tiltX || 0) * Math.PI / 180;
      const ty = (e.tiltY || 0) * Math.PI / 180;
      rawAngle = Math.atan2(ty, tx);
      tiltAmount = Math.min(Math.hypot(tx, ty) / 1.0, 1);
    }

    // Smooth angle via components (avoids wrap-around issues)
    const rc = Math.cos(rawAngle), rs = Math.sin(rawAngle);
    smTiltCos += (rc - smTiltCos) * 0.3;
    smTiltSin += (rs - smTiltSin) * 0.3;
    curAngle = Math.atan2(smTiltSin, smTiltCos);

    const rawAspect = 1 - tiltInfluence * tiltAmount * 0.8;
    smAspect += (rawAspect - smAspect) * 0.3;
    curAspect = Math.max(0.1, smAspect);
  }

  // ══════════════════════════════════════════════
  //  Brush engine
  // ══════════════════════════════════════════════
  function computeRadius(pressure, velocity) {
    const pMapped = Math.pow(Math.max(pressure, 0.001), pressureCurve);
    const sizeT = 1 - pressureToSize * (1 - pMapped);
    let r = maxRadius * Math.max(minSizePct, sizeT);
    if (speedThinning > 0 && velocity > 0) {
      const vn = Math.min(velocity / 2.5, 1);
      r *= 1 - speedThinning * vn * 0.7;
    }
    return Math.max(0.4, r);
  }

  function computeAlpha(pressure) {
    const pMapped = Math.pow(Math.max(pressure, 0.001), pressureCurve);
    const opacT = 1 - pressureToOpac * (1 - pMapped);
    return brushOpacity * Math.max(0.03, opacT);
  }

  function drawDab(x, y, r, alpha, angle, aspect) {
    const d = r * 2;
    sctx.save();
    sctx.translate(x, y);
    if (tiltInfluence > 0 && aspect < 0.98) {
      sctx.rotate(angle);
      sctx.scale(1, aspect);
    }
    sctx.globalAlpha = alpha;
    sctx.drawImage(dabCvs, -r, -r, d, d);
    sctx.restore();
  }

  function stamp(x, y, pressure, velocity, angle, aspect) {
    const r = computeRadius(pressure, velocity);
    const alpha = computeAlpha(pressure);

    // Main dab
    drawDab(x, y, r, alpha, angle, aspect);

    // Scatter: extra dabs around the main position
    if (scatterRadius > 0) {
      const spread = r * scatterRadius * 3;
      for (let s = 0; s < scatterDensity; s++) {
        const a = Math.random() * Math.PI * 2;
        const d = Math.random() * spread;
        const sr = r * (0.3 + Math.random() * 0.7); // varied size
        const sa = alpha * (0.4 + Math.random() * 0.6); // varied opacity
        drawDab(x + Math.cos(a) * d, y + Math.sin(a) * d, sr, sa, angle, aspect);
      }
    }
  }

  function strokeSegment(x0, y0, p0, x1, y1, p1, vel, angle, aspect) {
    const dx = x1 - x0, dy = y1 - y0;
    const dist = Math.hypot(dx, dy);
    if (dist < 0.3) { stamp(x1, y1, p1, vel, angle, aspect); return; }

    const avgP = (p0 + p1) / 2;
    const pMapped = Math.pow(Math.max(avgP, 0.001), pressureCurve);
    const avgR = maxRadius * Math.max(minSizePct, 1 - pressureToSize * (1 - pMapped));
    const spacing = Math.max(0.5, avgR * (0.18 + softness * 0.12));
    const n = Math.max(1, Math.ceil(dist / spacing));

    for (let i = 0; i <= n; i++) {
      const t = i / n;
      stamp(x0 + dx * t, y0 + dy * t, p0 + (p1 - p0) * t, vel, angle, aspect);
    }
  }

  // ══════════════════════════════════════════════
  //  HUD
  // ══════════════════════════════════════════════
  function updateHUD(e) {
    sType.textContent = e.pointerType || '--';
    const p = e.pressure ?? 0;
    sPressure.textContent = p.toFixed(3);
    sPbar.style.width = (p * 100) + '%';
    sTiltX.textContent = (e.tiltX ?? 0) + '\u00B0';
    sTiltY.textContent = (e.tiltY ?? 0) + '\u00B0';
    sAlt.textContent = e.altitudeAngle != null
      ? (e.altitudeAngle * 180 / Math.PI).toFixed(1) + '\u00B0' : '--';
    sAzi.textContent = e.azimuthAngle != null
      ? (e.azimuthAngle * 180 / Math.PI).toFixed(1) + '\u00B0' : '--';
    sTwist.textContent = (e.twist ?? 0) + '\u00B0';
    sPos.textContent = Math.round(e.clientX) + ', ' + Math.round(e.clientY);
  }

  // ══════════════════════════════════════════════
  //  Pointer events
  // ══════════════════════════════════════════════
  function onDown(e) {
    if (e.pointerType === 'touch') return;
    e.preventDefault();
    canvas.setPointerCapture(e.pointerId);

    const x = e.clientX, y = e.clientY, p = e.pressure || 0.5;

    // Only allow drawing in the right 25%
    if (x < W * 0.75) return;

    // Lock to the track the pen landed in
    for (const tb of trackBounds) {
      if (y >= tb.top && y <= tb.bot) {
        activeTrackTop = tb.top;
        activeTrackBot = tb.bot;
        break;
      }
    }

    drawing = true;
    const cy = Math.max(activeTrackTop, Math.min(activeTrackBot, y));
    smoothX = prevDX = x;
    smoothY = prevDY = cy;
    smoothP = prevDP = p;
    lastTime = performance.now();
    lastVelocity = 0;
    smTiltCos = 0; smTiltSin = 0; smAspect = 1;
    computeTilt(e);

    stamp(x, cy, p, 0, curAngle, curAspect);
    updateHUD(e);
  }

  function onMove(e) {
    updateHUD(e);
    if (!drawing) return;
    e.preventDefault();

    const events = e.getCoalescedEvents ? e.getCoalescedEvents() : [e];
    const now = performance.now();

    for (const ce of events) {
      const rx = ce.clientX;
      const ry = Math.max(activeTrackTop, Math.min(activeTrackBot, ce.clientY));
      const rp = ce.pressure || 0.5;

      // Streamline smoothing
      const s = streamline;
      smoothX += (rx - smoothX) * (1 - s);
      smoothY += (ry - smoothY) * (1 - s);
      smoothP += (rp - smoothP) * 0.4;

      // Tilt
      computeTilt(ce);

      // Velocity
      const dt = Math.max(now - lastTime, 1);
      const dist = Math.hypot(smoothX - prevDX, smoothY - prevDY);
      const vel = dist / dt;
      lastVelocity += (vel - lastVelocity) * 0.3;
      lastTime = now;

      strokeSegment(prevDX, prevDY, prevDP, smoothX, smoothY, smoothP, lastVelocity, curAngle, curAspect);
      prevDX = smoothX;
      prevDY = smoothY;
      prevDP = smoothP;
    }
  }

  function onUp(e) {
    drawing = false;
    if (e) updateHUD(e);
  }

  canvas.addEventListener('pointerdown', onDown);
  canvas.addEventListener('pointermove', onMove);
  canvas.addEventListener('pointerup', onUp);
  canvas.addEventListener('pointercancel', onUp);

  // ══════════════════════════════════════════════
  //  Animation loop
  // ══════════════════════════════════════════════
  function frame() {
    if (!paused && scrollSpeed > 0) {
      const shift = scrollSpeed * dpr;
      sctx.save();
      sctx.setTransform(1, 0, 0, 1, 0, 0);
      sctx.globalCompositeOperation = 'copy';
      sctx.drawImage(score, -shift, 0);
      sctx.globalCompositeOperation = 'source-over';
      sctx.restore();
      if (drawing) { prevDX -= scrollSpeed; smoothX -= scrollSpeed; }
    }

    // Render
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(score, 0, 0);
    ctx.restore();
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // Shade non-track areas
    if (trackBounds.length) {
      ctx.fillStyle = 'rgba(255,255,255,0.03)';
      ctx.fillRect(0, 0, W, trackBounds[0].top);                          // top margin
      ctx.fillRect(0, trackBounds[0].bot, W, trackBounds[1].top - trackBounds[0].bot); // gap 1-2
      ctx.fillRect(0, trackBounds[1].bot, W, trackBounds[2].top - trackBounds[1].bot); // gap 2-3
      ctx.fillRect(0, trackBounds[2].bot, W, H - trackBounds[2].bot);     // bottom margin
    }

    // Track boundary lines (6 lines: top/bottom of each track)
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.lineWidth = 1;
    for (const y of lanes) {
      ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
    }

    // Draw zone indicator (one dashed line per track)
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.05)';
    ctx.setLineDash([5, 10]);
    for (const tb of trackBounds) {
      ctx.beginPath();
      ctx.moveTo(W * 0.75, tb.top);
      ctx.lineTo(W * 0.75, tb.bot);
      ctx.stroke();
    }
    ctx.restore();

    requestAnimationFrame(frame);
  }

  // ══════════════════════════════════════════════
  //  Vertical sliders
  // ══════════════════════════════════════════════
  function setupVSlider(id, fillId, min, max, initial, onChange) {
    const el = document.getElementById(id);
    const fill = document.getElementById(fillId);
    let val = initial;
    let active = false;

    function setVal(v) {
      val = Math.max(min, Math.min(max, v));
      fill.style.height = ((val - min) / (max - min) * 100) + '%';
      onChange(val);
    }

    function fromY(clientY) {
      const r = el.getBoundingClientRect();
      const ratio = 1 - (clientY - r.top) / r.height;
      setVal(min + ratio * (max - min));
    }

    el.addEventListener('pointerdown', e => {
      e.preventDefault(); e.stopPropagation();
      active = true;
      el.setPointerCapture(e.pointerId);
      fromY(e.clientY);
    });
    el.addEventListener('pointermove', e => { if (active) fromY(e.clientY); });
    el.addEventListener('pointerup', () => active = false);
    el.addEventListener('pointercancel', () => active = false);

    setVal(initial);
    return { get: () => val, set: setVal };
  }

  const brushDot = document.getElementById('brush-dot');
  function updatePreview() {
    const d = Math.max(4, Math.min(36, maxRadius * 2));
    brushDot.style.width = d + 'px';
    brushDot.style.height = d + 'px';
    brushDot.style.opacity = brushOpacity;
  }

  const vsSize = setupVSlider('vs-size', 'vsf-size', 1, 150, maxRadius, v => {
    maxRadius = v;
    updatePreview();
  });
  const vsOpacity = setupVSlider('vs-opacity', 'vsf-opacity', 0.05, 1, brushOpacity, v => {
    brushOpacity = v;
    updatePreview();
  });
  setupVSlider('vs-speed', 'vsf-speed', 0, 6, scrollSpeed, v => {
    scrollSpeed = v;
  });
  updatePreview();

  // ══════════════════════════════════════════════
  //  Brush settings panel
  // ══════════════════════════════════════════════
  const brushPanel = document.getElementById('brush-panel');
  document.getElementById('btn-brush-panel').addEventListener('click', () => {
    brushPanel.classList.toggle('open');
  });
  document.getElementById('bp-close').addEventListener('click', () => {
    brushPanel.classList.remove('open');
  });

  function bpSlider(inputId, valId, mapFn) {
    const input = document.getElementById(inputId);
    const vEl = document.getElementById(valId);
    input.addEventListener('input', () => {
      vEl.textContent = input.value;
      mapFn(parseFloat(input.value));
    });
    mapFn(parseFloat(input.value));
  }

  bpSlider('bp-stream', 'bpv-stream', v => { streamline = v / 100; });
  bpSlider('bp-pcurve', 'bpv-pcurve', v => { pressureCurve = v / 100; });
  bpSlider('bp-psize',  'bpv-psize',  v => { pressureToSize = v / 100; });
  bpSlider('bp-popac',  'bpv-popac',  v => { pressureToOpac = v / 100; });
  bpSlider('bp-vel',    'bpv-vel',    v => { speedThinning = v / 100; });
  bpSlider('bp-min',    'bpv-min',    v => { minSizePct = v / 100; });
  bpSlider('bp-soft',   'bpv-soft',   v => { softness = v / 100; buildDab(); });
  bpSlider('bp-tilt',   'bpv-tilt',   v => { tiltInfluence = v / 100; });
  bpSlider('bp-scatter','bpv-scatter', v => { scatterRadius = v / 100; });
  bpSlider('bp-sdens',  'bpv-sdens',  v => { scatterDensity = Math.round(v); });

  // ══════════════════════════════════════════════
  //  Sidebar buttons
  // ══════════════════════════════════════════════
  document.getElementById('btn-clear').addEventListener('click', () => {
    sctx.save();
    sctx.setTransform(1, 0, 0, 1, 0, 0);
    sctx.clearRect(0, 0, score.width, score.height);
    sctx.restore();
  });

  const btnPause = document.getElementById('btn-pause');
  btnPause.addEventListener('click', () => {
    paused = !paused;
    btnPause.classList.toggle('active', paused);
    btnPause.innerHTML = paused ? '&#9654;' : '&#9646;&#9646;';
  });

  // ── Init ──
  window.addEventListener('resize', resize);
  resize();
  buildDab();
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
